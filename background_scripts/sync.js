// Generated by CoffeeScript 1.8.0
(function() {
  var Sync, root,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Sync = Sync = {
    debug: false,
    storage: chrome.storage.sync,
    doNotSync: ["settingsVersion", "previousVersion"],
    init: function() {
      chrome.storage.onChanged.addListener(function(changes, area) {
        return Sync.handleStorageUpdate(changes, area);
      });
      return this.fetchAsync();
    },
    fetchAsync: function() {
      return this.storage.get(null, (function(_this) {
        return function(items) {
          var key, value, _results;
          if (chrome.runtime.lastError === void 0) {
            _results = [];
            for (key in items) {
              if (!__hasProp.call(items, key)) continue;
              value = items[key];
              _this.log("fetchAsync: " + key + " <- " + value);
              _results.push(_this.storeAndPropagate(key, value));
            }
            return _results;
          } else {
            console.log("callback for Sync.fetchAsync() indicates error");
            return console.log(chrome.runtime.lastError);
          }
        };
      })(this));
    },
    handleStorageUpdate: function(changes, area) {
      var change, key, _results;
      _results = [];
      for (key in changes) {
        if (!__hasProp.call(changes, key)) continue;
        change = changes[key];
        this.log("handleStorageUpdate: " + key + " <- " + change.newValue);
        _results.push(this.storeAndPropagate(key, change != null ? change.newValue : void 0));
      }
      return _results;
    },
    storeAndPropagate: function(key, value) {
      var defaultValue, defaultValueJSON;
      if (!key in Settings.defaults) {
        return;
      }
      if (!this.shouldSyncKey(key)) {
        return;
      }
      if (value && key in localStorage && localStorage[key] === value) {
        return;
      }
      defaultValue = Settings.defaults[key];
      defaultValueJSON = JSON.stringify(defaultValue);
      if (value && value !== defaultValueJSON) {
        this.log("storeAndPropagate update: " + key + "=" + value);
        localStorage[key] = value;
        return Settings.performPostUpdateHook(key, JSON.parse(value));
      } else {
        this.log("storeAndPropagate clear: " + key);
        if (key in localStorage) {
          delete localStorage[key];
        }
        return Settings.performPostUpdateHook(key, defaultValue);
      }
    },
    set: function(key, value) {
      var key_value;
      if (this.shouldSyncKey(key)) {
        this.log("set scheduled: " + key + "=" + value);
        key_value = {};
        key_value[key] = value;
        return this.storage.set(key_value, (function(_this) {
          return function() {
            if (chrome.runtime.lastError) {
              console.log("callback for Sync.set() indicates error: " + key + " <- " + value);
              return console.log(chrome.runtime.lastError);
            }
          };
        })(this));
      }
    },
    clear: function(key) {
      if (this.shouldSyncKey(key)) {
        this.log("clear scheduled: " + key);
        return this.storage.remove(key, (function(_this) {
          return function() {
            if (chrome.runtime.lastError) {
              console.log("for Sync.clear() indicates error: " + key);
              return console.log(chrome.runtime.lastError);
            }
          };
        })(this));
      }
    },
    shouldSyncKey: function(key) {
      return __indexOf.call(this.doNotSync, key) < 0;
    },
    log: function(msg) {
      if (this.debug) {
        return console.log("Sync: " + msg);
      }
    }
  };

}).call(this);
